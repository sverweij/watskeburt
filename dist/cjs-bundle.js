var a=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var E=(e,t)=>{for(var n in t)a(e,n,{get:t[n],enumerable:!0})},A=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of y(t))!x.call(e,o)&&o!==n&&a(e,o,{get:()=>t[o],enumerable:!(r=w(t,o))||r.enumerable});return e};var C=e=>A(a({},"__esModule",{value:!0}),e);var B={};E(B,{getSHA:()=>j,list:()=>$});module.exports=C(B);var u=require("os"),_=new RegExp("^(?<changeType>[ACDMRTUXB])(?<similarity>[0-9]{3})?[ 	]+(?<name>[^ 	]+)[ 	]*(?<newName>[^ 	]+)?$"),R=new RegExp("^(?<stagedChangeType>[ ACDMRTUXB?!])(?<unStagedChangeType>[ ACDMRTUXB?!])[ 	]+(?<name>[^ 	]+)(( -> )(?<newName>[^ 	]+))?$"),L={A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"type changed",U:"unmerged",B:"pairing broken"," ":"unmodified","?":"untracked","!":"ignored"};function s(e){return L[e]||"unknown"}function D(e){let t=e.match(R),n={};if(t){let r=s(t.groups.stagedChangeType),o=s(t.groups.unStagedChangeType);n.changeType=r==="unmodified"?o:r,t.groups.newName?(n.name=t.groups.newName,n.oldName=t.groups.name):n.name=t.groups.name}return n}function U(e){let t=e.match(_),n={};return t&&(n.changeType=s(t.groups.changeType),t.groups.similarity&&(n.similarity=Number.parseInt(t.groups.similarity,10)),t.groups.newName?(n.name=t.groups.newName,n.oldName=t.groups.name):n.name=t.groups.name),n}function g(e){return e.split(u.EOL).filter(Boolean).map(D).filter(({changeType:t})=>Boolean(t))}function l(e){return e.split(u.EOL).filter(Boolean).map(U).filter(({changeType:t})=>Boolean(t))}var i=require("child_process");function d(e){return e instanceof Buffer?e.toString("utf8"):e}function H(e){throw e.code&&e.code==="ENOENT"?new Error("git executable not found"):new Error(`internal spawn error: ${e}`)}function c(e,t,n){let r=n("git",e,{cwd:process.cwd(),env:process.env});if(r.error,r.status===0)return d(r.stdout);throw new Error(t[r.status]||`internal git error: ${r.status} (${d(r.stderr)})`)}function T(e=i.spawnSync){let t={129:`'${process.cwd()}' does not seem to be a git repository`};return c(["status","--porcelain"],t,e)}function h(e,t=i.spawnSync){let n={128:`revision '${e}' unknown `,129:`'${process.cwd()}' does not seem to be a git repository`};return c(["diff",e,"--name-status"],n,t)}function S(e=i.spawnSync){return c(["rev-parse","HEAD"],{},e).slice(0,40)}var N=require("path");function f(e,t=[".js",".jsx",".mjs",".cjs",".ts",".tsx",".vue",".vuex",".json"],n=["modified","added","renamed","copied","untracked"]){return`^(${e.filter(o=>n.includes(o.changeType)).map(({name:o})=>o).filter(o=>t.includes((0,N.extname)(o))).join("|")})$`}function p(e){return JSON.stringify(e,null,2)}var O={regex:f,json:p,object:e=>e},v="object";function m(e,t){return O[t||v](e)}function $(e,t){let n=l(h(e)),r=t||{};return r.trackedOnly||(n=n.concat(g(T()).filter(({changeType:o})=>o==="untracked"))),m(n,r.outputType)}function j(){return S()}0&&(module.exports={getSHA,list});
