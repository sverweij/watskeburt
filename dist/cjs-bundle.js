"use strict";var i=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var A=Object.prototype.hasOwnProperty;var _=(e,t)=>{for(var n in t)i(e,n,{get:t[n],enumerable:!0})},D=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of C(t))!A.call(e,o)&&o!==n&&i(e,o,{get:()=>t[o],enumerable:!(r=x(t,o))||r.enumerable});return e};var L=e=>D(i({},"__esModule",{value:!0}),e);var P={};_(P,{getSHASync:()=>k,listSync:()=>F});module.exports=L(P);var c=require("os"),R=/^(?<changeType>[ACDMRTUXB])(?<similarity>[0-9]{3})?[ \t]+(?<name>[^ \t]+)[ \t]*(?<newName>[^ \t]+)?$/,O=/^(?<stagedChangeType>[ ACDMRTUXB?!])(?<unStagedChangeType>[ ACDMRTUXB?!])[ \t]+(?<name>[^ \t]+)(( -> )(?<newName>[^ \t]+))?$/,U={A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"type changed",U:"unmerged",B:"pairing broken"," ":"unmodified","?":"untracked","!":"ignored"};function u(e){return U[e]||"unknown"}function $(e){let t=e.match(O),n={};if(t){let r=u(t.groups.stagedChangeType),o=u(t.groups.unStagedChangeType);n.changeType=r==="unmodified"?o:r,t.groups.newName?(n.name=t.groups.newName,n.oldName=t.groups.name):n.name=t.groups.name}return n}function v(e){let t=e.match(R),n={};return t&&(n.changeType=u(t.groups.changeType),t.groups.newName?(n.name=t.groups.newName,n.oldName=t.groups.name):n.name=t.groups.name),n}function T(e){return e.split(c.EOL).filter(Boolean).map($).filter(({changeType:t})=>Boolean(t))}function S(e){return e.split(c.EOL).filter(Boolean).map(v).filter(({changeType:t})=>Boolean(t))}var s=require("child_process");function h(e){return e instanceof Buffer?e.toString("utf8"):e}function M(e){throw e.code==="ENOENT"?new Error("git executable not found"):new Error(`internal spawn error: ${e}`)}function f(e,t,n){let r=n("git",e,{cwd:process.cwd(),env:process.env});if(r.error&&M(r.error),r.status===0)return h(r.stdout);throw new Error(t[r.status]||`internal git error: ${r.status} (${h(r.stderr)})`)}function N(e=s.spawnSync){let t={129:`'${process.cwd()}' does not seem to be a git repository`};return f(["status","--porcelain"],t,e)}function y(e,t,n=s.spawnSync){let r={128:`revision '${e}' ${t?`(or '${t}') `:""}unknown`,129:`'${process.cwd()}' does not seem to be a git repository`};return f(t?["diff",e,t,"--name-status"]:["diff",e,"--name-status"],r,n)}function l(e=s.spawnSync){return f(["rev-parse","HEAD"],{},e).slice(0,40)}var E=require("path"),B=new Set([".cjs",".cjsx",".coffee",".csx",".cts",".js",".json",".jsx",".litcoffee",".ls",".mjs",".mts",".svelte",".ts",".tsx",".vue",".vuex"]),H=new Set(["modified","added","renamed","copied","untracked"]);function m(e,t=B,n=H){return`^(${e.filter(o=>n.has(o.changeType)).map(({name:o})=>o).filter(o=>t.has((0,E.extname)(o))).join("|")})$`}function p(e){return JSON.stringify(e,null,2)}var j=e=>e,I=new Map([["regex",m],["json",p]]);function g(e,t){return(I.get(t)||j)(e)}function k(){return l()}function F(e,t,n){let r=e||l(),o=t||null,d=n||{},a=S(y(r,o));return d.trackedOnly||(a=a.concat(T(N()).filter(({changeType:w})=>w==="untracked"))),g(a,d.outputType)}0&&(module.exports={getSHASync,listSync});
