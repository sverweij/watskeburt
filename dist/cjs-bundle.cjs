"use strict";var y=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var M=Object.prototype.hasOwnProperty;var b=(t,e)=>{for(var n in e)y(t,n,{get:e[n],enumerable:!0})},B=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of k(e))!M.call(t,o)&&o!==n&&y(t,o,{get:()=>e[o],enumerable:!(r=_(e,o))||r.enumerable});return t};var H=t=>B(y({},"__esModule",{value:!0}),t);var K={};b(K,{getSHA:()=>m,getSHASync:()=>p,list:()=>z,listSync:()=>q});module.exports=H(K);var T=require("os"),U=/^(?<changeType>[ACDMRTUXB])(?<similarity>[0-9]{3})?[ \t]+(?<name>[^ \t]+)[ \t]*(?<newName>[^ \t]+)?$/,j=/^(?<stagedChangeType>[ ACDMRTUXB?!])(?<unStagedChangeType>[ ACDMRTUXB?!])[ \t]+(?<name>[^ \t]+)(( -> )(?<newName>[^ \t]+))?$/,R={A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"type changed",U:"unmerged",B:"pairing broken"," ":"unmodified","?":"untracked","!":"ignored"};function d(t){return R[t]??"unknown"}function v(t){let e=t.match(j),n={};if(e!=null&&e.groups){let r=d(e.groups.stagedChangeType),o=d(e.groups.unStagedChangeType);n.changeType=r==="unmodified"?o:r,e.groups.newName?(n.name=e.groups.newName,n.oldName=e.groups.name):n.name=e.groups.name}return n}function F(t){let e=t.match(U),n={};return e!=null&&e.groups&&(n.changeType=d(e.groups.changeType),e.groups.newName?(n.name=e.groups.newName,n.oldName=e.groups.name):n.name=e.groups.name),n}function h(t){return t.split(T.EOL).filter(Boolean).map(v).filter(({name:e,changeType:n})=>!!e&&!!n)}function S(t){return t.split(T.EOL).filter(Boolean).map(F).filter(({name:e,changeType:n})=>!!e&&!!n)}var u=require("child_process");function N(t){return t instanceof Buffer?t.toString("utf8"):t}function G(t){throw t.code==="ENOENT"?new Error("git executable not found"):new Error(`internal spawn error: ${t}`)}function w(t,e,n){let r=n("git",t,{cwd:process.cwd(),env:process.env});if(r.error&&G(r.error),r.status===0)return N(r.stdout);throw new Error(e[r.status??0]||`internal git error: ${r.status} (${N(r.stderr)})`)}function A(t=u.spawnSync){let e={129:`'${process.cwd()}' does not seem to be a git repository`};return w(["status","--porcelain"],e,t)}function D(t,e,n=u.spawnSync){let r={128:`revision '${t}' ${e?`(or '${e}') `:""}unknown`,129:`'${process.cwd()}' does not seem to be a git repository`};return w(e?["diff",t,e,"--name-status"]:["diff",t,"--name-status"],r,n)}function p(t=u.spawnSync){return w(["rev-parse","HEAD"],{},t).slice(0,40)}var L=require("path"),X=new Set([".cjs",".cjsx",".coffee",".csx",".cts",".js",".json",".jsx",".litcoffee",".ls",".mjs",".mts",".svelte",".ts",".tsx",".vue",".vuex"]),J=new Set(["modified","added","renamed","copied","untracked"]);function C(t,e=X,n=J){return`^(${t.filter(o=>n.has(o.changeType)).map(({name:o})=>o).filter(o=>e.has((0,L.extname)(o))).join("|")})$`}function I(t){return JSON.stringify(t,null,2)}var Y=t=>t,V=new Map([["regex",C],["json",I]]);function f(t,e){return(V.get(e??"unknown")||Y)(t)}var l=require("child_process");function O(t){return t instanceof Buffer?t.toString("utf8"):t}function E(t,e,n){let r=n("git",t,{cwd:process.cwd(),env:process.env}),o="",a="";return new Promise((c,i)=>{var g,x;(g=r.stdout)==null||g.on("data",s=>{o=o.concat(s)}),(x=r.stderr)==null||x.on("data",s=>{a=a.concat(s)}),r.on("close",s=>{s===0?c(O(o)):i(new Error(e[s??0]||`internal git error: ${s} (${O(a)})`))}),r.on("error",s=>{(s==null?void 0:s.code)==="ENOENT"?i(new Error("git executable not found")):i(new Error(`internal spawn error: ${s}`))})})}async function $(t=l.spawn){let e={129:`'${process.cwd()}' does not seem to be a git repository`};return await E(["status","--porcelain"],e,t)}async function P(t,e,n=l.spawn){let r={128:`revision '${t}' ${e?`(or '${e}') `:""}unknown`,129:`'${process.cwd()}' does not seem to be a git repository`};return await E(e?["diff",t,e,"--name-status"]:["diff",t,"--name-status"],r,n)}async function m(t=l.spawn){return(await E(["rev-parse","HEAD"],{},t)).slice(0,40)}function q(t,e,n){let r=t||p(),o=n||{},a=S(D(r,e));return o.trackedOnly||(a=a.concat(h(A()).filter(({changeType:c})=>c==="untracked"))),f(a,o.outputType)}async function z(t,e,n){let r=t||await m(),o=n||{},[a,c]=await Promise.all([P(r,e),o.trackedOnly?"":$()]),i=S(a);return o.trackedOnly||(i=i.concat(h(c).filter(({changeType:g})=>g==="untracked"))),f(i,o.outputType)}0&&(module.exports={getSHA,getSHASync,list,listSync});
