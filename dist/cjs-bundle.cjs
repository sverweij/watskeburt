"use strict";var l=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var k=Object.prototype.hasOwnProperty;var M=(t,e)=>{for(var n in e)l(t,n,{get:e[n],enumerable:!0})},H=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of _(e))!k.call(t,s)&&s!==n&&l(t,s,{get:()=>e[s],enumerable:!(r=v(e,s))||r.enumerable});return t};var b=t=>H(l({},"__esModule",{value:!0}),t);var tt={};M(tt,{getSHA:()=>W,getSHASync:()=>Z,list:()=>K,listSync:()=>Q});module.exports=b(tt);var y=require("os"),B=/^(?<changeType>[ACDMRTUXB])(?<similarity>[0-9]{3})?[ \t]+(?<name>[^ \t]+)[ \t]*(?<newName>[^ \t]+)?$/,U=/^(?<stagedChangeType>[ ACDMRTUXB?!])(?<unStagedChangeType>[ ACDMRTUXB?!])[ \t]+(?<name>[^ \t]+)(( -> )(?<newName>[^ \t]+))?$/,j={A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"type changed",U:"unmerged",B:"pairing broken"," ":"unmodified","?":"untracked","!":"ignored"};function d(t){return t.split(y.EOL).filter(Boolean).map(R).filter(({name:e,changeType:n})=>!!e&&!!n)}function R(t){let e=t.match(U),n={};if(e!=null&&e.groups){let r=m(e.groups.stagedChangeType),s=m(e.groups.unStagedChangeType);n.changeType=r==="unmodified"?s:r,e.groups.newName?(n.name=e.groups.newName,n.oldName=e.groups.name):n.name=e.groups.name}return n}function T(t){return t.split(y.EOL).filter(Boolean).map(F).filter(({name:e,changeType:n})=>!!e&&!!n)}function F(t){let e=t.match(B),n={};return e!=null&&e.groups&&(n.changeType=m(e.groups.changeType),e.groups.newName?(n.name=e.groups.newName,n.oldName=e.groups.name):n.name=e.groups.name),n}function m(t){return j[t]??"unknown"}var p=require("child_process");function N(t=p.spawnSync){let e={129:`'${process.cwd()}' does not seem to be a git repository`};return h(["status","--porcelain"],e,t)}function D(t,e,n=p.spawnSync){let r={128:`revision '${t}' ${e?`(or '${e}') `:""}unknown`,129:`'${process.cwd()}' does not seem to be a git repository`};return h(e?["diff",t,e,"--name-status"]:["diff",t,"--name-status"],r,n)}function S(t=p.spawnSync){return h(["rev-parse","HEAD"],{},t).slice(0,40)}function h(t,e,n){let r=n("git",t,{cwd:process.cwd(),env:process.env});if(r.error&&G(r.error),r.status===0)return A(r.stdout);throw new Error(e[r.status??0]||`internal git error: ${r.status} (${A(r.stderr)})`)}function A(t){return t instanceof Buffer?t.toString("utf8"):t}function G(t){throw t.code==="ENOENT"?new Error("git executable not found"):new Error(`internal spawn error: ${t}`)}var u=require("child_process");async function O(t=u.spawn){let e={129:`'${process.cwd()}' does not seem to be a git repository`};return await C(["status","--porcelain"],e,t)}async function P(t,e,n=u.spawn){let r={128:`revision '${t}' ${e?`(or '${e}') `:""}unknown`,129:`'${process.cwd()}' does not seem to be a git repository`};return await C(e?["diff",t,e,"--name-status"]:["diff",t,"--name-status"],r,n)}async function w(t=u.spawn){return(await C(["rev-parse","HEAD"],{},t)).slice(0,40)}function C(t,e,n){let r=n("git",t,{cwd:process.cwd(),env:process.env}),s="",i="";return new Promise((c,a)=>{var g,x;(g=r.stdout)==null||g.on("data",o=>{s=s.concat(o)}),(x=r.stderr)==null||x.on("data",o=>{i=i.concat(o)}),r.on("close",o=>{o===0?c(L(s)):a(new Error(e[o??0]||`internal git error: ${o} (${L(i)})`))}),r.on("error",o=>{(o==null?void 0:o.code)==="ENOENT"?a(new Error("git executable not found")):a(new Error(`internal spawn error: ${o}`))})})}function L(t){return t instanceof Buffer?t.toString("utf8"):t}var $=require("path"),Y=new Set([".cjs",".cjsx",".coffee",".csx",".cts",".js",".json",".jsx",".litcoffee",".ls",".mjs",".mts",".svelte",".ts",".tsx",".vue",".vuex"]),V=new Set(["modified","added","renamed","copied","untracked"]);function I(t,e=Y,n=V){return`^(${t.filter(s=>n.has(s.changeType)).map(({name:s})=>s).filter(s=>e.has((0,$.extname)(s))).map(s=>s.replace(/\./g,"\\.")).join("|")})$`}function E(t){return JSON.stringify(t,null,2)}var q=t=>t,z=new Map([["regex",I],["json",E]]);function f(t,e){return(z.get(e??"unknown")||q)(t)}async function K(t,e,n){let r=t||await w(),s=n||{},[i,c]=await Promise.all([P(r,e),s.trackedOnly?"":O()]),a=T(i);return s.trackedOnly||(a=a.concat(d(c).filter(({changeType:g})=>g==="untracked"))),f(a,s.outputType)}function Q(t,e,n){let r=t||S(),s=n||{},i=T(D(r,e));return s.trackedOnly||(i=i.concat(d(N()).filter(({changeType:c})=>c==="untracked"))),f(i,s.outputType)}function W(){return w()}function Z(){return S()}0&&(module.exports={getSHA,getSHASync,list,listSync});
