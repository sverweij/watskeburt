import{EOL as m}from"os";var C=/^(?<changeType>[ACDMRTUXB])(?<similarity>[0-9]{3})?[ \t]+(?<name>[^ \t]+)[ \t]*(?<newName>[^ \t]+)?$/,I=/^(?<stagedChangeType>[ ACDMRTUXB?!])(?<unStagedChangeType>[ ACDMRTUXB?!])[ \t]+(?<name>[^ \t]+)(( -> )(?<newName>[^ \t]+))?$/,w={A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"type changed",U:"unmerged",B:"pairing broken"," ":"unmodified","?":"untracked","!":"ignored"};function s(t){return w[t]??"unknown"}function E(t){let e=t.match(I),n={};if(e!=null&&e.groups){let r=s(e.groups.stagedChangeType),o=s(e.groups.unStagedChangeType);n.changeType=r==="unmodified"?o:r,e.groups.newName?(n.name=e.groups.newName,n.oldName=e.groups.name):n.name=e.groups.name}return n}function N(t){let e=t.match(C),n={};return e!=null&&e.groups&&(n.changeType=s(e.groups.changeType),e.groups.newName?(n.name=e.groups.newName,n.oldName=e.groups.name):n.name=e.groups.name),n}function T(t){return t.split(m).filter(Boolean).map(E).filter(({name:e,changeType:n})=>Boolean(e)&&Boolean(n))}function y(t){return t.split(m).filter(Boolean).map(N).filter(({name:e,changeType:n})=>Boolean(e)&&Boolean(n))}import{spawnSync as i}from"child_process";function l(t){return t instanceof Buffer?t.toString("utf8"):t}function x(t){throw t.code==="ENOENT"?new Error("git executable not found"):new Error(`internal spawn error: ${t}`)}function p(t,e,n){let r=n("git",t,{cwd:process.cwd(),env:process.env});if(r.error&&x(r.error),r.status===0)return l(r.stdout);throw new Error(e[r.status??0]||`internal git error: ${r.status} (${l(r.stderr)})`)}function d(t=i){let e={129:`'${process.cwd()}' does not seem to be a git repository`};return p(["status","--porcelain"],e,t)}function h(t,e,n=i){let r={128:`revision '${t}' ${e?`(or '${e}') `:""}unknown`,129:`'${process.cwd()}' does not seem to be a git repository`};return p(e?["diff",t,e,"--name-status"]:["diff",t,"--name-status"],r,n)}function g(t=i){return p(["rev-parse","HEAD"],{},t).slice(0,40)}import{extname as A}from"path";var _=new Set([".cjs",".cjsx",".coffee",".csx",".cts",".js",".json",".jsx",".litcoffee",".ls",".mjs",".mts",".svelte",".ts",".tsx",".vue",".vuex"]),D=new Set(["modified","added","renamed","copied","untracked"]);function u(t,e=_,n=D){return`^(${t.filter(o=>n.has(o.changeType)).map(({name:o})=>o).filter(o=>e.has(A(o))).join("|")})$`}function c(t){return JSON.stringify(t,null,2)}var L=t=>t,O=new Map([["regex",u],["json",c]]);function f(t,e){return(O.get(e??"unknown")||L)(t)}function J(){return g()}function Y(t,e,n){let r=t||g(),o=n||{},a=y(h(r,e));return o.trackedOnly||(a=a.concat(T(d()).filter(({changeType:S})=>S==="untracked"))),f(a,o.outputType)}export{J as getSHASync,Y as listSync};
